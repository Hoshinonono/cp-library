---
data:
  _extendedDependsOn:
  - icon: ':heavy_check_mark:'
    path: DataStructure/segtree_dual.hpp
    title: "\u53CC\u5BFE\u30BB\u30B0\u30E1\u30F3\u30C8\u6728"
  - icon: ':heavy_check_mark:'
    path: Graph/csr.hpp
    title: Compressed Sparse Row (CSR)
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/3187
    links:
    - https://yukicoder.me/problems/no/3187
  bundledCode: "#line 1 \"Test/yukicoder/yuki3178.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/3187\"\
    \r\n\r\n#include <bits/stdc++.h>\r\n#include <Graph/csr.hpp>\r\n#include <DataStructure/segtree_dual.hpp>\r\
    \nusing namespace std;\r\n\r\n#if 1 // ACL\u306Emodint\r\nnamespace internal {\r\
    \nconstexpr long long safe_mod(long long x, long long m) {\r\n    x %= m;\r\n\
    \    if (x < 0) x += m;\r\n    return x;\r\n}\r\nstruct barrett {\r\n    unsigned\
    \ int _m;\r\n    unsigned long long im;\r\n    explicit barrett(unsigned int m)\
    \ : _m(m), im((unsigned long long)(-1) / m + 1) {}\r\n    unsigned int umod()\
    \ const { return _m; }\r\n    unsigned int mul(unsigned int a, unsigned int b)\
    \ const {\r\n        unsigned long long z = a;\r\n        z *= b;\r\n        unsigned\
    \ int v = (unsigned int)(z % _m);\r\n        return v;\r\n    }\r\n};\r\nconstexpr\
    \ long long pow_mod_constexpr(long long x, long long n, int m) {\r\n    if (m\
    \ == 1) return 0;\r\n    unsigned int _m = (unsigned int)(m);\r\n    unsigned\
    \ long long r = 1;\r\n    unsigned long long y = safe_mod(x, m);\r\n    while\
    \ (n) {\r\n        if (n & 1) r = (r * y) % _m;\r\n        y = (y * y) % _m;\r\
    \n        n >>= 1;\r\n    }\r\n    return r;\r\n}\r\nconstexpr bool is_prime_constexpr(int\
    \ n) {\r\n    if (n <= 1) return false;\r\n    if (n == 2 || n == 7 || n == 61)\
    \ return true;\r\n    if (n % 2 == 0) return false;\r\n    long long d = n - 1;\r\
    \n    while (d % 2 == 0) d /= 2;\r\n    constexpr long long bases[3] = {2, 7,\
    \ 61};\r\n    for (long long a : bases) {\r\n        long long t = d;\r\n    \
    \    long long y = pow_mod_constexpr(a, t, n);\r\n        while (t != n - 1 &&\
    \ y != 1 && y != n - 1) {\r\n            y = y * y % n;\r\n            t <<= 1;\r\
    \n        }\r\n        if (y != n - 1 && t % 2 == 0) {\r\n            return false;\r\
    \n        }\r\n    }\r\n    return true;\r\n}\r\ntemplate <int n> constexpr bool\
    \ is_prime = is_prime_constexpr(n);\r\nconstexpr std::pair<long long, long long>\
    \ inv_gcd(long long a, long long b) {\r\n    a = safe_mod(a, b);\r\n    if (a\
    \ == 0) return {b, 0};\r\n    long long s = b, t = a;\r\n    long long m0 = 0,\
    \ m1 = 1;\r\n    while (t) {\r\n        long long u = s / t;\r\n        s -= t\
    \ * u;\r\n        m0 -= m1 * u;\r\n        auto tmp = s;\r\n        s = t;\r\n\
    \        t = tmp;\r\n        tmp = m0;\r\n        m0 = m1;\r\n        m1 = tmp;\r\
    \n    }\r\n    if (m0 < 0) m0 += b / s;\r\n    return {s, m0};\r\n}\r\nconstexpr\
    \ int primitive_root_constexpr(int m) {\r\n    if (m == 2) return 1;\r\n    if\
    \ (m == 167772161) return 3;\r\n    if (m == 469762049) return 3;\r\n    if (m\
    \ == 754974721) return 11;\r\n    if (m == 998244353) return 3;\r\n    int divs[20]\
    \ = {};\r\n    divs[0] = 2;\r\n    int cnt = 1;\r\n    int x = (m - 1) / 2;\r\n\
    \    while (x % 2 == 0) x /= 2;\r\n    for (int i = 3; (long long)(i)*i <= x;\
    \ i += 2) {\r\n        if (x % i == 0) {\r\n            divs[cnt++] = i;\r\n \
    \           while (x % i == 0) {\r\n                x /= i;\r\n            }\r\
    \n        }\r\n    }\r\n    if (x > 1) {\r\n        divs[cnt++] = x;\r\n    }\r\
    \n    for (int g = 2;; g++) {\r\n        bool ok = true;\r\n        for (int i\
    \ = 0; i < cnt; i++) {\r\n            if (pow_mod_constexpr(g, (m - 1) / divs[i],\
    \ m) == 1) {\r\n                ok = false;\r\n                break;\r\n    \
    \        }\r\n        }\r\n        if (ok) return g;\r\n    }\r\n}\r\ntemplate\
    \ <int m> constexpr int primitive_root = primitive_root_constexpr(m);\r\nunsigned\
    \ long long floor_sum_unsigned(unsigned long long n,\r\n                     \
    \                 unsigned long long m,\r\n                                  \
    \    unsigned long long a,\r\n                                      unsigned long\
    \ long b) {\r\n    unsigned long long ans = 0;\r\n    while (true) {\r\n     \
    \   if (a >= m) {\r\n            ans += n * (n - 1) / 2 * (a / m);\r\n       \
    \     a %= m;\r\n        }\r\n        if (b >= m) {\r\n            ans += n *\
    \ (b / m);\r\n            b %= m;\r\n        }\r\n        unsigned long long y_max\
    \ = a * n + b;\r\n        if (y_max < m) break;\r\n        n = (unsigned long\
    \ long)(y_max / m);\r\n        b = (unsigned long long)(y_max % m);\r\n      \
    \  std::swap(m, a);\r\n    }\r\n    return ans;\r\n}\r\ntemplate <class T> using\
    \ is_integral = typename std::is_integral<T>;\r\ntemplate <class T>\r\nusing is_signed_int\
    \ =\r\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\
    \n                              std::true_type,\r\n                          \
    \    std::false_type>::type;\r\ntemplate <class T>\r\nusing is_unsigned_int =\r\
    \n    typename std::conditional<is_integral<T>::value &&\r\n                 \
    \                 std::is_unsigned<T>::value,\r\n                            \
    \  std::true_type,\r\n                              std::false_type>::type;\r\n\
    template <class T>\r\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\
    \n                                              std::make_unsigned<T>,\r\n   \
    \                                           std::common_type<T>>::type;\r\ntemplate\
    \ <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\
    \ntemplate <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\
    \ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\r\n\
    struct modint_base {};\r\nstruct static_modint_base : modint_base {};\r\ntemplate\
    \ <class T> using is_modint = std::is_base_of<modint_base, T>;\r\ntemplate <class\
    \ T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\r\n}  // namespace\
    \ internal\r\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\r\nstruct\
    \ static_modint : internal::static_modint_base {\r\n    using mint = static_modint;\r\
    \n  public:\r\n    static constexpr int mod() { return m; }\r\n    static mint\
    \ raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n\
    \    }\r\n    static_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>*\
    \ = nullptr>\r\n    static_modint(T v) {\r\n        long long x = (long long)(v\
    \ % (long long)(umod()));\r\n        if (x < 0) x += umod();\r\n        _v = (unsigned\
    \ int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>*\
    \ = nullptr>\r\n    static_modint(T v) {\r\n        _v = (unsigned int)(v % umod());\r\
    \n    }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++()\
    \ {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\
    \n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n \
    \       _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\
    \n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\
    \n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n    \
    \    --*this;\r\n        return result;\r\n    }\r\n\r\n    mint& operator+=(const\
    \ mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\
    \n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n\
    \        _v -= rhs._v;\r\n        if (_v >= umod()) _v += umod();\r\n        return\
    \ *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n        unsigned\
    \ long long z = _v;\r\n        z *= rhs._v;\r\n        _v = (unsigned int)(z %\
    \ umod());\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint&\
    \ rhs) { return *this = *this * rhs.inv(); }\r\n    mint operator+() const { return\
    \ *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n    mint\
    \ pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this,\
    \ r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n        \
    \    x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n   \
    \ }\r\n    mint inv() const {\r\n        if (prime) {\r\n            assert(_v);\r\
    \n            return pow(umod() - 2);\r\n        } else {\r\n            auto\
    \ eg = internal::inv_gcd(_v, m);\r\n            assert(eg.first == 1);\r\n   \
    \         return eg.second;\r\n        }\r\n    }\r\n    friend mint operator+(const\
    \ mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\
    \n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return\
    \ mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const\
    \ mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint\
    \ operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /=\
    \ rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs)\
    \ {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const\
    \ mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\
    \n    //\u81EA\u5206\u3067\u52A0\u3048\u305F\u3082\u306E\r\n    friend istream&\
    \ operator>>(istream& os,mint& rhs) noexcept {\r\n        long long v;\r\n   \
    \     rhs = mint{(os >> v, v)};\r\n        return os;\r\n    }\r\n    friend constexpr\
    \ ostream& operator << (ostream &os, const mint& rhs) noexcept {\r\n        return\
    \ os << rhs._v;\r\n    }\r\n  private:\r\n    unsigned int _v;\r\n    static constexpr\
    \ unsigned int umod() { return m; }\r\n    static constexpr bool prime = internal::is_prime<m>;\r\
    \n};\r\ntemplate <int id> struct dynamic_modint : internal::modint_base {\r\n\
    \    using mint = dynamic_modint;\r\n  public:\r\n    static int mod() { return\
    \ (int)(bt.umod()); }\r\n    static void set_mod(int m) {\r\n        assert(1\
    \ <= m);\r\n        bt = internal::barrett(m);\r\n    }\r\n    static mint raw(int\
    \ v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\
    \n    dynamic_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>*\
    \ = nullptr>\r\n    dynamic_modint(T v) {\r\n        long long x = (long long)(v\
    \ % (long long)(mod()));\r\n        if (x < 0) x += mod();\r\n        _v = (unsigned\
    \ int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>*\
    \ = nullptr>\r\n    dynamic_modint(T v) {\r\n        _v = (unsigned int)(v % mod());\r\
    \n    }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++()\
    \ {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\
    \n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n \
    \       _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\
    \n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\
    \n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n    \
    \    --*this;\r\n        return result;\r\n    }\r\n\r\n    mint& operator+=(const\
    \ mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\
    \n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n\
    \        _v += mod() - rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n\
    \        return *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n\
    \        _v = bt.mul(_v, rhs._v);\r\n        return *this;\r\n    }\r\n    mint&\
    \ operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n    mint\
    \ operator+() const { return *this; }\r\n    mint operator-() const { return mint()\
    \ - *this; }\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\
    \n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n &\
    \ 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n \
    \       return r;\r\n    }\r\n    mint inv() const {\r\n        auto eg = internal::inv_gcd(_v,\
    \ mod());\r\n        assert(eg.first == 1);\r\n        return eg.second;\r\n \
    \   }\r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n   \
    \     return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint&\
    \ lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n   \
    \ friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return\
    \ mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const\
    \ mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool\
    \ operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\
    \n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n\
    \        return lhs._v != rhs._v;\r\n    }\r\n    //\u81EA\u5206\u3067\u52A0\u3048\
    \u305F\u3082\u306E\r\n    friend istream& operator>>(istream& os,mint& rhs) noexcept\
    \ {\r\n        long long v;\r\n        rhs = mint{(os >> v, v)};\r\n        return\
    \ os;\r\n    }\r\n    friend constexpr ostream& operator << (ostream &os, const\
    \ mint& rhs) noexcept {\r\n        return os << rhs._v;\r\n    }\r\n  private:\r\
    \n    unsigned int _v;\r\n    static internal::barrett bt;\r\n    static unsigned\
    \ int umod() { return bt.umod(); }\r\n};\r\ntemplate <int id> internal::barrett\
    \ dynamic_modint<id>::bt(998244353);\r\nusing modint998244353 = static_modint<998244353>;\r\
    \nusing modint1000000007 = static_modint<1000000007>;\r\nusing modint = dynamic_modint<-1>;\r\
    \nnamespace internal {\r\ntemplate <class T>\r\nusing is_static_modint = std::is_base_of<internal::static_modint_base,\
    \ T>;\r\ntemplate <class T>\r\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\r\
    \ntemplate <class> struct is_dynamic_modint : public std::false_type {};\r\ntemplate\
    \ <int id>\r\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type\
    \ {};\r\ntemplate <class T>\r\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\r\
    \n}  // namespace internal\r\n#endif\r\n\r\nusing mint = modint;\r\nusing S =\
    \ mint;\r\n// bf \u306B af \u3092\u4F5C\u7528\u3055\u305B\u305F\u6642\u306E\u5909\
    \u5316\r\nS mapping(S af, S bf){ return bf + af; }\r\n// \u6052\u7B49\u5199\u50CF\
    \r\nS id(){ return 0; }\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\
    \n    cin.tie(0);\r\n    int n, p;\r\n    cin >> n >> p;\r\n    mint::set_mod(p);\r\
    \n    csr<int> dv(n + 1);\r\n    for(int i = 1; i <= n; i++){\r\n        for(int\
    \ j = 2 * i; j <= n; j += i) dv.add_edge(j, i);\r\n    }\r\n    dv.build();\r\n\
    \    vector<mint> coef(n + 1), prv(n + 1);\r\n    mint ans;\r\n    int mn = n;\r\
    \n    for(int i = 1; i <= n; i++){\r\n        int v = n - (n % i);\r\n       \
    \ coef[v]++;\r\n        mn = min(mn, v);\r\n    }\r\n    dual_segtree<S, mapping,\
    \ id> seg(n + 1);\r\n    prv[n] = 1;\r\n    for(int i = n; i >= 3; i--){\r\n \
    \       mint div = mint::raw(i - 1 - dv[i].size()).inv();\r\n        ans += prv[i]\
    \ * mint(i) * div;\r\n        seg.apply(mn, i, prv[i] * div);\r\n        for(int\
    \ j = 0; j < dv[i].size(); j++){\r\n            int d = dv[i][j];\r\n        \
    \    int v = i - d;\r\n            prv[v] += seg[v] * coef[v];\r\n           \
    \ seg[v] = 0;\r\n            coef[v]++;\r\n            mn = min(mn, v);\r\n  \
    \      }\r\n    }\r\n    cout << ans.val() << '\\n';\r\n}\r\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/3187\"\r\n\r\n#include\
    \ <bits/stdc++.h>\r\n#include <Graph/csr.hpp>\r\n#include <DataStructure/segtree_dual.hpp>\r\
    \nusing namespace std;\r\n\r\n#if 1 // ACL\u306Emodint\r\nnamespace internal {\r\
    \nconstexpr long long safe_mod(long long x, long long m) {\r\n    x %= m;\r\n\
    \    if (x < 0) x += m;\r\n    return x;\r\n}\r\nstruct barrett {\r\n    unsigned\
    \ int _m;\r\n    unsigned long long im;\r\n    explicit barrett(unsigned int m)\
    \ : _m(m), im((unsigned long long)(-1) / m + 1) {}\r\n    unsigned int umod()\
    \ const { return _m; }\r\n    unsigned int mul(unsigned int a, unsigned int b)\
    \ const {\r\n        unsigned long long z = a;\r\n        z *= b;\r\n        unsigned\
    \ int v = (unsigned int)(z % _m);\r\n        return v;\r\n    }\r\n};\r\nconstexpr\
    \ long long pow_mod_constexpr(long long x, long long n, int m) {\r\n    if (m\
    \ == 1) return 0;\r\n    unsigned int _m = (unsigned int)(m);\r\n    unsigned\
    \ long long r = 1;\r\n    unsigned long long y = safe_mod(x, m);\r\n    while\
    \ (n) {\r\n        if (n & 1) r = (r * y) % _m;\r\n        y = (y * y) % _m;\r\
    \n        n >>= 1;\r\n    }\r\n    return r;\r\n}\r\nconstexpr bool is_prime_constexpr(int\
    \ n) {\r\n    if (n <= 1) return false;\r\n    if (n == 2 || n == 7 || n == 61)\
    \ return true;\r\n    if (n % 2 == 0) return false;\r\n    long long d = n - 1;\r\
    \n    while (d % 2 == 0) d /= 2;\r\n    constexpr long long bases[3] = {2, 7,\
    \ 61};\r\n    for (long long a : bases) {\r\n        long long t = d;\r\n    \
    \    long long y = pow_mod_constexpr(a, t, n);\r\n        while (t != n - 1 &&\
    \ y != 1 && y != n - 1) {\r\n            y = y * y % n;\r\n            t <<= 1;\r\
    \n        }\r\n        if (y != n - 1 && t % 2 == 0) {\r\n            return false;\r\
    \n        }\r\n    }\r\n    return true;\r\n}\r\ntemplate <int n> constexpr bool\
    \ is_prime = is_prime_constexpr(n);\r\nconstexpr std::pair<long long, long long>\
    \ inv_gcd(long long a, long long b) {\r\n    a = safe_mod(a, b);\r\n    if (a\
    \ == 0) return {b, 0};\r\n    long long s = b, t = a;\r\n    long long m0 = 0,\
    \ m1 = 1;\r\n    while (t) {\r\n        long long u = s / t;\r\n        s -= t\
    \ * u;\r\n        m0 -= m1 * u;\r\n        auto tmp = s;\r\n        s = t;\r\n\
    \        t = tmp;\r\n        tmp = m0;\r\n        m0 = m1;\r\n        m1 = tmp;\r\
    \n    }\r\n    if (m0 < 0) m0 += b / s;\r\n    return {s, m0};\r\n}\r\nconstexpr\
    \ int primitive_root_constexpr(int m) {\r\n    if (m == 2) return 1;\r\n    if\
    \ (m == 167772161) return 3;\r\n    if (m == 469762049) return 3;\r\n    if (m\
    \ == 754974721) return 11;\r\n    if (m == 998244353) return 3;\r\n    int divs[20]\
    \ = {};\r\n    divs[0] = 2;\r\n    int cnt = 1;\r\n    int x = (m - 1) / 2;\r\n\
    \    while (x % 2 == 0) x /= 2;\r\n    for (int i = 3; (long long)(i)*i <= x;\
    \ i += 2) {\r\n        if (x % i == 0) {\r\n            divs[cnt++] = i;\r\n \
    \           while (x % i == 0) {\r\n                x /= i;\r\n            }\r\
    \n        }\r\n    }\r\n    if (x > 1) {\r\n        divs[cnt++] = x;\r\n    }\r\
    \n    for (int g = 2;; g++) {\r\n        bool ok = true;\r\n        for (int i\
    \ = 0; i < cnt; i++) {\r\n            if (pow_mod_constexpr(g, (m - 1) / divs[i],\
    \ m) == 1) {\r\n                ok = false;\r\n                break;\r\n    \
    \        }\r\n        }\r\n        if (ok) return g;\r\n    }\r\n}\r\ntemplate\
    \ <int m> constexpr int primitive_root = primitive_root_constexpr(m);\r\nunsigned\
    \ long long floor_sum_unsigned(unsigned long long n,\r\n                     \
    \                 unsigned long long m,\r\n                                  \
    \    unsigned long long a,\r\n                                      unsigned long\
    \ long b) {\r\n    unsigned long long ans = 0;\r\n    while (true) {\r\n     \
    \   if (a >= m) {\r\n            ans += n * (n - 1) / 2 * (a / m);\r\n       \
    \     a %= m;\r\n        }\r\n        if (b >= m) {\r\n            ans += n *\
    \ (b / m);\r\n            b %= m;\r\n        }\r\n        unsigned long long y_max\
    \ = a * n + b;\r\n        if (y_max < m) break;\r\n        n = (unsigned long\
    \ long)(y_max / m);\r\n        b = (unsigned long long)(y_max % m);\r\n      \
    \  std::swap(m, a);\r\n    }\r\n    return ans;\r\n}\r\ntemplate <class T> using\
    \ is_integral = typename std::is_integral<T>;\r\ntemplate <class T>\r\nusing is_signed_int\
    \ =\r\n    typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,\r\
    \n                              std::true_type,\r\n                          \
    \    std::false_type>::type;\r\ntemplate <class T>\r\nusing is_unsigned_int =\r\
    \n    typename std::conditional<is_integral<T>::value &&\r\n                 \
    \                 std::is_unsigned<T>::value,\r\n                            \
    \  std::true_type,\r\n                              std::false_type>::type;\r\n\
    template <class T>\r\nusing to_unsigned = typename std::conditional<is_signed_int<T>::value,\r\
    \n                                              std::make_unsigned<T>,\r\n   \
    \                                           std::common_type<T>>::type;\r\ntemplate\
    \ <class T> using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;\r\
    \ntemplate <class T> using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;\r\
    \ntemplate <class T> using to_unsigned_t = typename to_unsigned<T>::type;\r\n\
    struct modint_base {};\r\nstruct static_modint_base : modint_base {};\r\ntemplate\
    \ <class T> using is_modint = std::is_base_of<modint_base, T>;\r\ntemplate <class\
    \ T> using is_modint_t = std::enable_if_t<is_modint<T>::value>;\r\n}  // namespace\
    \ internal\r\ntemplate <int m, std::enable_if_t<(1 <= m)>* = nullptr>\r\nstruct\
    \ static_modint : internal::static_modint_base {\r\n    using mint = static_modint;\r\
    \n  public:\r\n    static constexpr int mod() { return m; }\r\n    static mint\
    \ raw(int v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n\
    \    }\r\n    static_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>*\
    \ = nullptr>\r\n    static_modint(T v) {\r\n        long long x = (long long)(v\
    \ % (long long)(umod()));\r\n        if (x < 0) x += umod();\r\n        _v = (unsigned\
    \ int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>*\
    \ = nullptr>\r\n    static_modint(T v) {\r\n        _v = (unsigned int)(v % umod());\r\
    \n    }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++()\
    \ {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\
    \n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n \
    \       _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\
    \n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\
    \n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n    \
    \    --*this;\r\n        return result;\r\n    }\r\n\r\n    mint& operator+=(const\
    \ mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\
    \n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n\
    \        _v -= rhs._v;\r\n        if (_v >= umod()) _v += umod();\r\n        return\
    \ *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n        unsigned\
    \ long long z = _v;\r\n        z *= rhs._v;\r\n        _v = (unsigned int)(z %\
    \ umod());\r\n        return *this;\r\n    }\r\n    mint& operator/=(const mint&\
    \ rhs) { return *this = *this * rhs.inv(); }\r\n    mint operator+() const { return\
    \ *this; }\r\n    mint operator-() const { return mint() - *this; }\r\n    mint\
    \ pow(long long n) const {\r\n        assert(0 <= n);\r\n        mint x = *this,\
    \ r = 1;\r\n        while (n) {\r\n            if (n & 1) r *= x;\r\n        \
    \    x *= x;\r\n            n >>= 1;\r\n        }\r\n        return r;\r\n   \
    \ }\r\n    mint inv() const {\r\n        if (prime) {\r\n            assert(_v);\r\
    \n            return pow(umod() - 2);\r\n        } else {\r\n            auto\
    \ eg = internal::inv_gcd(_v, m);\r\n            assert(eg.first == 1);\r\n   \
    \         return eg.second;\r\n        }\r\n    }\r\n    friend mint operator+(const\
    \ mint& lhs, const mint& rhs) {\r\n        return mint(lhs) += rhs;\r\n    }\r\
    \n    friend mint operator-(const mint& lhs, const mint& rhs) {\r\n        return\
    \ mint(lhs) -= rhs;\r\n    }\r\n    friend mint operator*(const mint& lhs, const\
    \ mint& rhs) {\r\n        return mint(lhs) *= rhs;\r\n    }\r\n    friend mint\
    \ operator/(const mint& lhs, const mint& rhs) {\r\n        return mint(lhs) /=\
    \ rhs;\r\n    }\r\n    friend bool operator==(const mint& lhs, const mint& rhs)\
    \ {\r\n        return lhs._v == rhs._v;\r\n    }\r\n    friend bool operator!=(const\
    \ mint& lhs, const mint& rhs) {\r\n        return lhs._v != rhs._v;\r\n    }\r\
    \n    //\u81EA\u5206\u3067\u52A0\u3048\u305F\u3082\u306E\r\n    friend istream&\
    \ operator>>(istream& os,mint& rhs) noexcept {\r\n        long long v;\r\n   \
    \     rhs = mint{(os >> v, v)};\r\n        return os;\r\n    }\r\n    friend constexpr\
    \ ostream& operator << (ostream &os, const mint& rhs) noexcept {\r\n        return\
    \ os << rhs._v;\r\n    }\r\n  private:\r\n    unsigned int _v;\r\n    static constexpr\
    \ unsigned int umod() { return m; }\r\n    static constexpr bool prime = internal::is_prime<m>;\r\
    \n};\r\ntemplate <int id> struct dynamic_modint : internal::modint_base {\r\n\
    \    using mint = dynamic_modint;\r\n  public:\r\n    static int mod() { return\
    \ (int)(bt.umod()); }\r\n    static void set_mod(int m) {\r\n        assert(1\
    \ <= m);\r\n        bt = internal::barrett(m);\r\n    }\r\n    static mint raw(int\
    \ v) {\r\n        mint x;\r\n        x._v = v;\r\n        return x;\r\n    }\r\
    \n    dynamic_modint() : _v(0) {}\r\n    template <class T, internal::is_signed_int_t<T>*\
    \ = nullptr>\r\n    dynamic_modint(T v) {\r\n        long long x = (long long)(v\
    \ % (long long)(mod()));\r\n        if (x < 0) x += mod();\r\n        _v = (unsigned\
    \ int)(x);\r\n    }\r\n    template <class T, internal::is_unsigned_int_t<T>*\
    \ = nullptr>\r\n    dynamic_modint(T v) {\r\n        _v = (unsigned int)(v % mod());\r\
    \n    }\r\n    unsigned int val() const { return _v; }\r\n    mint& operator++()\
    \ {\r\n        _v++;\r\n        if (_v == umod()) _v = 0;\r\n        return *this;\r\
    \n    }\r\n    mint& operator--() {\r\n        if (_v == 0) _v = umod();\r\n \
    \       _v--;\r\n        return *this;\r\n    }\r\n    mint operator++(int) {\r\
    \n        mint result = *this;\r\n        ++*this;\r\n        return result;\r\
    \n    }\r\n    mint operator--(int) {\r\n        mint result = *this;\r\n    \
    \    --*this;\r\n        return result;\r\n    }\r\n\r\n    mint& operator+=(const\
    \ mint& rhs) {\r\n        _v += rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\
    \n        return *this;\r\n    }\r\n    mint& operator-=(const mint& rhs) {\r\n\
    \        _v += mod() - rhs._v;\r\n        if (_v >= umod()) _v -= umod();\r\n\
    \        return *this;\r\n    }\r\n    mint& operator*=(const mint& rhs) {\r\n\
    \        _v = bt.mul(_v, rhs._v);\r\n        return *this;\r\n    }\r\n    mint&\
    \ operator/=(const mint& rhs) { return *this = *this * rhs.inv(); }\r\n    mint\
    \ operator+() const { return *this; }\r\n    mint operator-() const { return mint()\
    \ - *this; }\r\n    mint pow(long long n) const {\r\n        assert(0 <= n);\r\
    \n        mint x = *this, r = 1;\r\n        while (n) {\r\n            if (n &\
    \ 1) r *= x;\r\n            x *= x;\r\n            n >>= 1;\r\n        }\r\n \
    \       return r;\r\n    }\r\n    mint inv() const {\r\n        auto eg = internal::inv_gcd(_v,\
    \ mod());\r\n        assert(eg.first == 1);\r\n        return eg.second;\r\n \
    \   }\r\n    friend mint operator+(const mint& lhs, const mint& rhs) {\r\n   \
    \     return mint(lhs) += rhs;\r\n    }\r\n    friend mint operator-(const mint&\
    \ lhs, const mint& rhs) {\r\n        return mint(lhs) -= rhs;\r\n    }\r\n   \
    \ friend mint operator*(const mint& lhs, const mint& rhs) {\r\n        return\
    \ mint(lhs) *= rhs;\r\n    }\r\n    friend mint operator/(const mint& lhs, const\
    \ mint& rhs) {\r\n        return mint(lhs) /= rhs;\r\n    }\r\n    friend bool\
    \ operator==(const mint& lhs, const mint& rhs) {\r\n        return lhs._v == rhs._v;\r\
    \n    }\r\n    friend bool operator!=(const mint& lhs, const mint& rhs) {\r\n\
    \        return lhs._v != rhs._v;\r\n    }\r\n    //\u81EA\u5206\u3067\u52A0\u3048\
    \u305F\u3082\u306E\r\n    friend istream& operator>>(istream& os,mint& rhs) noexcept\
    \ {\r\n        long long v;\r\n        rhs = mint{(os >> v, v)};\r\n        return\
    \ os;\r\n    }\r\n    friend constexpr ostream& operator << (ostream &os, const\
    \ mint& rhs) noexcept {\r\n        return os << rhs._v;\r\n    }\r\n  private:\r\
    \n    unsigned int _v;\r\n    static internal::barrett bt;\r\n    static unsigned\
    \ int umod() { return bt.umod(); }\r\n};\r\ntemplate <int id> internal::barrett\
    \ dynamic_modint<id>::bt(998244353);\r\nusing modint998244353 = static_modint<998244353>;\r\
    \nusing modint1000000007 = static_modint<1000000007>;\r\nusing modint = dynamic_modint<-1>;\r\
    \nnamespace internal {\r\ntemplate <class T>\r\nusing is_static_modint = std::is_base_of<internal::static_modint_base,\
    \ T>;\r\ntemplate <class T>\r\nusing is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;\r\
    \ntemplate <class> struct is_dynamic_modint : public std::false_type {};\r\ntemplate\
    \ <int id>\r\nstruct is_dynamic_modint<dynamic_modint<id>> : public std::true_type\
    \ {};\r\ntemplate <class T>\r\nusing is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;\r\
    \n}  // namespace internal\r\n#endif\r\n\r\nusing mint = modint;\r\nusing S =\
    \ mint;\r\n// bf \u306B af \u3092\u4F5C\u7528\u3055\u305B\u305F\u6642\u306E\u5909\
    \u5316\r\nS mapping(S af, S bf){ return bf + af; }\r\n// \u6052\u7B49\u5199\u50CF\
    \r\nS id(){ return 0; }\r\n\r\nint main() {\r\n    ios::sync_with_stdio(false);\r\
    \n    cin.tie(0);\r\n    int n, p;\r\n    cin >> n >> p;\r\n    mint::set_mod(p);\r\
    \n    csr<int> dv(n + 1);\r\n    for(int i = 1; i <= n; i++){\r\n        for(int\
    \ j = 2 * i; j <= n; j += i) dv.add_edge(j, i);\r\n    }\r\n    dv.build();\r\n\
    \    vector<mint> coef(n + 1), prv(n + 1);\r\n    mint ans;\r\n    int mn = n;\r\
    \n    for(int i = 1; i <= n; i++){\r\n        int v = n - (n % i);\r\n       \
    \ coef[v]++;\r\n        mn = min(mn, v);\r\n    }\r\n    dual_segtree<S, mapping,\
    \ id> seg(n + 1);\r\n    prv[n] = 1;\r\n    for(int i = n; i >= 3; i--){\r\n \
    \       mint div = mint::raw(i - 1 - dv[i].size()).inv();\r\n        ans += prv[i]\
    \ * mint(i) * div;\r\n        seg.apply(mn, i, prv[i] * div);\r\n        for(int\
    \ j = 0; j < dv[i].size(); j++){\r\n            int d = dv[i][j];\r\n        \
    \    int v = i - d;\r\n            prv[v] += seg[v] * coef[v];\r\n           \
    \ seg[v] = 0;\r\n            coef[v]++;\r\n            mn = min(mn, v);\r\n  \
    \      }\r\n    }\r\n    cout << ans.val() << '\\n';\r\n}\r\n"
  dependsOn:
  - Graph/csr.hpp
  - DataStructure/segtree_dual.hpp
  isVerificationFile: true
  path: Test/yukicoder/yuki3178.test.cpp
  requiredBy: []
  timestamp: '2025-06-21 08:54:56+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: Test/yukicoder/yuki3178.test.cpp
layout: document
redirect_from:
- /verify/Test/yukicoder/yuki3178.test.cpp
- /verify/Test/yukicoder/yuki3178.test.cpp.html
title: Test/yukicoder/yuki3178.test.cpp
---
